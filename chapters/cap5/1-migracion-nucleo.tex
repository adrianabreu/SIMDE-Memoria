\subsection{Analizadores léxicos}
El núcleo de la aplicación se basa en el uso del generador de analizadores 
léxicos FLEX para parsear un conjunto de instrucciones similar a las del MIPS IV. 
Para realizar el proceso de migración he tenido que comprender primero el 
funcionamiento de los analizadores léxicos.

\bigskip
Un analizador léxico es un programa que recibe como entrada el código fuente de 
otro programa y produce una salida compuesta de tokens o símbolos 
que alimentarán a un analizador sintáctico.

\bigskip
Para poroceder con esta tarea se ha aislado la implementación original y se han 
realizado pequeñas pruebas concretas.

\subsection{Lex}

A pesar de las multiples librerías, que hay disponibles, se decidió que la más adecuada 
para este proyecto era Lex https://www.npmjs.com/package/lex. 

El funcionamiento de este paquete es realmente sencillo, partiendo de un 
objeto Lexer, se definen las reglas y el token a retornar. De esta forma
el código original que alimentaba flex:

\begin{lstlisting}
H			[A-Fa-f0-9]
D			[0-9]
E			[Ee][+-]?{D}+
id			[A-Za-z_][A-Za-z0-9_]*
espacio		[ \t\v\f]
direccion	[+-]?{D}*"("[Rr]{D}+")"

%%

^{D}+			{	/* Esto es el numero de lineas del fichero */
					return LEXNLINEAS;
				}

#[+-]?{D}+		{ return LEXINMEDIATO; }
[Ff]{D}+		{ return LEXREGFP; }
[Rr]{D}+		{ return LEXREGGP; }
{id}			{ return LEXID; }
{id}":"			{ return LEXETIQUETA; }
{direccion}		{ return LEXDIRECCION; }

"//".*			{ /* Comentario */ }
{espacio}+		{ /* Espacio en blanco */ }
(.|\n)			{ /* Cosas extranas y retornos de carro */ }

%%

int yywrap() { return 1; }

int setYyin(char *nombre) {
	FILE *aux = fopen(nombre, "r");
	if (aux == NULL)
		return -1;
	yyrestart(aux);
	return 0;
}

int unsetYyin() {
	int res = fclose(yyin);
	yyin = NULL;
	return res;
}

char *getYytext() {
	return yytext;
}
\end{lstlisting}

Se ha convertido en: 

\begin{lstlisting}
export class Parser {

   private LEX: LEX;

   private _lexer;

   constructor() {

      this._lexer = new Lexer();

      this._lexer.addRule(/^[0-9]+/i, function (lexeme) {
         this.yytext = lexeme;
         return LEX.LINESNUMBER;
      }).addRule(/[Ff][0-9]+/i, function (lexeme) {
         this.yytext = lexeme;
         return LEX.REGFP;
      }).addRule(/[Rr][0-9]+/i, function (lexeme) {
         this.yytext = lexeme;
         return LEX.REGGP;
      }).addRule(/#[+-]?[0-9]+/i, function (lexeme) {
         this.yytext = lexeme;
         return LEX.INMEDIATE;
      }).addRule(/[A-Za-z][A-Za-z0-9]*\:/i, function (lexeme) {
         this.yytext = lexeme;
         return LEX.LABEL;
      }).addRule(/[A-Za-z][A-Za-z0-9]*/i, function (lexeme) {
         this.yytext = lexeme;
         return LEX.ID;
      }).addRule(/[+-]?[0-9]*\([Rr][0-9]+\)/i, function (lexeme) {
         this.yytext = lexeme;
         return LEX.ADDRESS;
      }).addRule(/^[0-9]+/i, function (lexeme) {
         return;
      }).addRule(/[ \t\v\f]+/i, function (lexeme) {
         return;
      }).addRule(/(.|\n)/i, function (lexeme) {
         return;
      }).addRule(/\/\/.*/, function (lexeme) {
         return;
      });
   }

   setInput(input: string) {
      this._lexer.input = input;
   }

   lex(): Lexema {
      let value = this._lexer.lex();
      return {
         value: value,
         yytext: this._lexer.yytext
      };
   }
}
\end{lstlisting}